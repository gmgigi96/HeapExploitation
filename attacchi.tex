\section{Attacchi\todo{Cambiare titolo}}
\todo{Da completare trattazione}
Nell'uso di \verb+malloc+ e \verb+free+ è responsabilità del programmatore:
\begin{enumerate}
	\item liberare una zona di memoria con \verb+free+ non ottenuta da \verb+malloc+\label{reg:free-no-malloc}\footnote{e funzioni \verb+malloc+ compatibili, come \verb+calloc+, \verb+realloc+ e \verb+memalign+.}
	\item non usare \verb+free+ su una zona di memoria più di una volta\label{reg:free2}
	\item assicurarsi di non sovrascrivere zone di memoria che eccedono la memoria richiesta con \verb+malloc+, per evitare \emph{heap overflow}\label{reg:overflow}
\end{enumerate}

Non rispettando queste regole il software ha delle vulnerabilità a vari attacchi. Gli Shellphish, un famoso gruppo di Capture The Flag (CTF), hanno elencato possibili attacchi nel repository Github \emph{how2heap}\cite{how2heap}.

La Tabella~\ref{tab:heap-att} mostra una lista di possibili attacchi che sfruttano alcune vulnerabilità presenti nel codice.

\begin{table}
	\label{tab:heap-att}
	\centering
	\begin{tabular}{lll}
		Nome dell'attacco & Tecnica \\
		\midrule
		Fastbin dup & Tricking malloc into returning an already-allocated heap pointer by abusing the fastbin freelist \\
		Fastbin dup into stack & Tricking malloc into returning a nearly-arbitrary pointer by abusing the fastbin freelist \\
		Fastbin dup consolidate & Tricking malloc into returning an already-allocated heap pointer by putting a pointer on both fastbin freelist and unsorted bin freelist \\
		Unsafe unlink & Exploiting free on a corrupted chunk to get arbitrary write \\
		House of spirit & Frees a fake fastbin chunk to get malloc to return a nearly-arbitrary pointer \\
		House of lore & Tricking malloc into returning a nearly-arbitrary pointer by abusing the smallbin freelist \\
		House of force & Exploiting the Top Chunk (Wilderness) header in order to get malloc to return a nearly-arbitrary pointer \\
		House of orange & Exploiting the Top Chunk (Wilderness) in order to gain arbitrary code execution \\
		Large bin attack & Exploiting the overwrite of a freed chunk on large bin freelist to write a large value into arbitrary address \\
		\bottomrule
	\end{tabular}
	\vspace{0.15in}
	\caption{Lista dei principali attacchi su heap (fonte~\cite{how2heap}}
\end{table}\todo{tradurre tabella}

In questa trattazione, in particolare, vedremo in dettaglio quattro di questi attacchi: \emph{fastbin dup}, \emph{fastbin dup into stack}, \emph{unsafe unlink} e \emph{house of spirit}.

\subsection{Fastbin dup}\label{cap:fastbin-dup}
\emph{Fastbin dup} permette di di ottenere da una \verb+malloc+ un chunk di memoria già allocato precedentemente, sfruttando i fastbin.

Vediamo l'attacco. Si inizia allocando inizialmente tre buffer con una dimensione che entri in un fastbin:
\begin{lstlisting}[style=CStyle]
int *a = malloc(8);
int *b = malloc(8);
int *c = malloc(8);
\end{lstlisting}

Rilasciamo \verb+a+:
\begin{lstlisting}[style=CStyle]
free(a)
\end{lstlisting}

A questo punto, \verb+a+ contiene ancora il puntatore del chunk di memoria in heap che ora è libero.
Se richiamassimo nuovamente \verb+free(a)+, la \verb+free+ si accorgerebbe che \verb+a+ è già stato liberato poichè si trova in testa a \verb+fastbin[0]+\footnote{Si noti che \verb+free+ in questo caso non può controllare il bit \verb+prev_inuse+ del chunk successivo in memoria poichè, come già detto nel precedente capitolo, in un fastbin i chunk non sono liberati effettivamente}.
Ispezionando il codice nella libc della \verb+free+ si può notare come questa faccia proprio questo controllo:
\begin{lstlisting}[style=CStyle]
/* Check that the top of the bin is not the record we are going to add
    (i.e., double free).  */
 if (__builtin_expect (old == p, 0))
   {
     errstr = "double free or corruption (fasttop)";
     goto errout;
   }
\end{lstlisting}
dove \verb+old+ è un puntatore al primo elemento del fastbin selezionato e \verb+p+ è il puntatore al chunk passato alla \verb+free+.

Per questo si invoca la \verb+free+ prima sul puntatore \verb+b+:
\begin{lstlisting}[style=CStyle]
free(b)
\end{lstlisting}
per poi invocarla nuovamente su \verb+a+:
\begin{lstlisting}[style=CStyle]
free(a)
\end{lstlisting}

\verb+fastbin[0]+ contiene ora questi puntatori: \verb+[a, b, a]+\footnote{con un abuso di notazione in quanto i puntatori restituiti dalla \verb+malloc+ non sono gli stessi dei chunk su cui opera invece la \verb+free+}.

Richiamando tre \verb+malloc+ consecutive:
\begin{lstlisting}[style=CStyle]
fprintf(stdout, "1st malloc(8): %p\n", malloc(8));
fprintf(stdout, "2nd malloc(8): %p\n", malloc(8));
fprintf(stdout, "3rd malloc(8): %p\n", malloc(8));
\end{lstlisting}
la prima e la terza \verb+malloc+ restituiranno lo stesso puntatore.

Da notare come questo bug è stato ottenuto poichè si è violata la regola~\ref{reg:free2}.

\subsection{Fastbin dup into stack}
\emph{Fastbin dup into stack} permette di ottenere un puntatore ad una zona in memoria arbitraria sfruttando, come in \emph{fastbin dup} (vedi Paragrafo~\ref{cap:fastbin-dup}), un fastbin.

Il prologo è lo stesso di \emph{fastbin dup}:
\begin{lstlisting}[style=CStyle]
int *a = malloc(8);
int *b = malloc(8);
int *c = malloc(8);

free(a);
free(b);
free(a);
\end{lstlisting}
in modo che \verb+fastbin[0]+ contenga la lista \verb+[a, b, a]+.

Si definisce inoltre una variabile \verb+stack_var+:
\begin{lstlisting}[style=CStyle]
unsigned long long stack_var;
\end{lstlisting}

Eseguendo una \verb+malloc+:
\begin{lstlisting}[style=CStyle]
int *d = malloc(8);
\end{lstlisting}

\verb+d+ contiene il puntatore ad \verb+a+\footnote{inteso come locazione in memoria, e non come puntatore alla variabile \verb+a+}.

Eseguendo nuovamente \verb+malloc(8)+, \verb+fastbin[0]+ conterrà \verb+[a]+, quindi se sovrascriviamo \verb+d+, sovrascriviamo anche \verb+a+ essendo lo stesso puntatore.

Sovrascriviamo quindi \verb+d+ con
\begin{lstlisting}[style=CStyle]
*d = (unsigned long long) (((char*)&stack_var) - sizeof(d));
\end{lstlisting}
modificando nello stesso tempo anche il campo \verb+fd+ di \verb+a+ (vedi Figura~\ref{fig:dup-stack}\todo{Inserire figura}).

Poichè la \verb+malloc+ effettua un controllo sulla \verb+size+ del chunk puntato da \verb+fd+, si assegna a \verb+stack_var+ la dimensione dei chunk contenuti nel \verb+fastbin[0]+:
\begin{lstlisting}[style=CStyle]
stack_var = 0x20;
\end{lstlisting}

Con \verb+malloc(8)+ si estrae da \verb+fastbin[0]+ il chunk \verb+a+, e poichè \verb+a->fd != NULL+, si inserisce in testa a \verb+fastbin[0]+ il puntatore \verb+a->fd+.
L'ultima \verb+malloc(8)+ ci consente di ottenere l'indirizzo scelto, in questo caso \verb|(char*)&stack_var + 8|.

In questo esempio si è scelto l'indirizzo di una variabile in stack come puntatore restituito da \verb+malloc+,  ma è possibile scegliere qualsiasi altro indirizzo: nella CTF presentata nel Paragrafo~\ref{cap:babyheap} l'indirizzo scelto è infatti una entry della \verb+.got section+.