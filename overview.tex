\section{Heap - CAMBIARE TITOLO}
Il funzionamento dell'heap dipende sia dalla piattaforma che dalla specifica implementazione. Ad esempio, in sistemi embedded le implementazioni normalmente utilizzati usano una lista concatenata con politica LIFO di blocchi di memoria di dimensione prefissata. Anche l'implementazione nella \emph{glibc}, la libreria standard del linguaggio C, di Linux è completamente differente da quella di Windows. In particolare, nella nostra trattazione, si vedrà l'implementazione dell'allocatore in heap nella glibc di un sistema Linux, \emph{ptmalloc2}, che deriva dalla \emph{ptmalloc}, che a sua volta deriva da una vecchia implementazione, \emph{dlmalloc}.

Uno dei problemi principali di cui soffre l'heap per sua natura è la \emph{frammentazione}: ci saranno quindi sezioni inutilizzate di memoria interposte tra sezioni in uso. Un buon allocatore dovrà limitare questo fenomeno, cercando di unire spazi contigui non utilizzati per soddisfare una richiesta.

\verb+malloc+ e \verb+free+, non sono gli unici modi con cui un programmatore C/C++ può interagire con l'heap: si possono infatti utilizzare funzioni come \verb+calloc+, \verb+realloc+, \verb+memalign+, che come \+malloc+, possono essere rilasciate con \verb+free+. I programmatori C++, invece, possono allocare memoria in heap con gli operatori \verb+new+ e \verb+new[]+, e deallocarla con \verb+delete+ e \verb+delete[]+.

L'allocatore della glibc di Linux, divide l'heap in chunk, ovvero porzioni di memoria più grandi rispetto a quelli richiesti da un programmatore. Questo per contenere metadati utili alla gestione dei chunk nell'heap.
Inoltre, poichè l'allocatore non conosce come un programmatore utilizza i dati allocati in memoria, esso deve garantire che i dati siano allineati. Questo ha impatto sulle performace di un software. La glibc allinea i chunk a 8 byte in sistemi a 32 bit ed a 16 byte in sistemi a 64 bit.

\subsection{Strategia di base}
Vediamo come vengono allocati i chunk, in un allocatore il cui funzionamento è molto semplificato:
\begin{enumerate}
	\item se un precedente chunk liberato con \verb+free+ è sufficientemente grande da contenere l'attuale, si usa questo chunk;\label{base:free}
	\item altrimenti, se c'è abbastanza spazio nel \emph{top chunk}, lo spazio più in alto nell'heap, si crea un nuovo chunk, riducendo il top chunk, e si restituisce questo;
	\item altrimenti, l'allocatore chiederà al kernel più spazio per l'heap, e se questo verrà aumentato sufficientemente da contenere il nuovo chunk viene creato dal nuovo spazio;\label{base:syscall}
	\item altrimenti, la richiesta non può essere soddisfatta e la \verb+malloc+ restituisce \verb+NULL+.
\end{enumerate}

Per il punto~\ref{base:free}, l'heap mantiene una o più liste di chunk, denominati \emph{bin}, gestite alcune con poliche LIFO, altre FIFO, altre ancora ordinate per chunk. Queste liste possono essere semplicemente o doppiamente concatenate, circolari, con nodi \emph{dummy}. Se è presente un chunck con una dimensione sufficientemente grande da soddisfare una richiesta, questo chunk viene estratto da uno dei bin. %INSERIRE FIGURA BIN

Nel punto~\ref{base:syscall}, le system call che l'allocatore può utilizzare per richiedere più spazio in heap sono \verb+brk+\cite{brk_syscall} e \verb+mmap+\cite{mmap_syscall}.
\verb+brk+ ottiene memoria, non inizializzata a zero, dal kernel incrementanfo il \emph{program break location}, o \emph{brk}. L'inizio dell'heap si trova invece in \emph{start\_brk}. Quando ASLR è disattivato, \emph{start\_brk} punta alla fine del BSS segment, altrimenti, se attivo, viene aggiunto un offset random (vedi Figura~\ref{fig:proc}). Ora, poichè il loader inserisce l'heap subito dopo BSS, l'effetto della syscall \verb+brk+ è quello di aumentare/diminuire la dimensione dell'heap.
\verb+mmap+ è utilizzato da \verb+malloc+ per chiedere al kernel zone mappate in memoria anonime, inizializzate a zero, usabili esclusivamente dal processo richiedente. Quest'ultima system call è usata quando \verb+sbrk+ fallisce, ad esempio perchè l'heap è cresciuto troppo da poter collidere con altre zone del processo, come shared libraries.

Le richieste per regioni di memoria molto ampie sono servite dall'allocatore direttamente da \verb+mmap+. Il comportamento è gestito dalla variabile \verb+M_MMAP_THRESHOLD+, che in sistemi a 32 bit è normalmente 128k e in sistemi a 64 bit è 32M. \'E possibile comunque cambiare la questa variabile con la funzione \verb+mallopt+. Le regioni \emph{mmappate} vengono marcate da una flag che indica che sono state ottenute da una chiamata ad \verb+mmap+, in modo tale che ad una richiesta a \verb+free+, la regione viene deallocata con la syscall \verb+munmap+.

\subsection{Chunk metadata}
Un chunk, come detto in precedenza, contiene dei metadati per la gestione degli stessi nell'heap. Nella glibc la struttura di un chunk è denominata \verb+malloc_chunk+, ed è così definita:

\begin{lstlisting}[style=CStyle]
	struct malloc_chunk {
	    INTERNAL_SIZE_T mchunk_prev_size;  /* Size of previous chunk (if free). */
	    INTERNAL_SIZE_T mchunk_size;       /* Size in bytes, including overhead */
	    struct malloc_chunk* fd;           /* double links -- used only if free */
	    struct malloc_chunk* bk;
	}
\end{lstlisting}

Alcuni di questi campi sono usati o meno in base al fatto che il chunk è in uso o libero.
Un chunk in uso ha questo aspetto:

\begin{verbatim}
    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}

Da notare che in questo caso \verb+fd+ e \verb+bk+ non sono utilizzati, ma coincidono con la parte del chunk utilizzabile dall'applicazione, lo \emph{user data}. \verb+mem+ è infatti il puntatore ritornato dalla \verb+malloc+.

Un chunk libero, quindi al'interno di un bin, avrà questo aspetto:

\begin{verbatim}
    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|0|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
Qui lo user data è occupato dai puntatori \verb+fd+ e \verb+bk+\footnote{in base al bin in cui andrà a finire il chunk possono essere usati o entrambi o solo uno dei due.}.

In entrambi i casi il campo \verb+mchunk_prev_size+ è utilizzato solo se il chunk precedente\footnote{in questo caso il chunk precedente è quello che lo precede fisicamente in memoria} è libero e se è in uso può contenere gli user data del chunk precedente.

Il lettore avrà anche notato la presenza di 3 lettere nel campo \verb+mchunk_size+, che corrispondono ai 3 bit meno significativi di questo campo:
\begin{itemize}
	\item \textbf{P (PREV\_INUSE)}: 0 quando il chunk precedente in memoria è libero e la dimensione di quest'ultimo è memorizzata nel primo campo. Se il bit è 1, il chunk precedente è utilizzato e non si può conoscere la sua dimensione.
	\item \textbf{M (IS\_MMAPPED)}: se 1 il chunk è ottenuto mediante la syscall \verb+mmap+. Gli altri due bit sono ignorati.
	\item \textbf{A (NON\_MAIN\_ARENA)}: se 0 il chunk è nel main arena. Ogni thread del processo riceve la sua arena e per questi chunk il bit è settato ad 1.
\end{itemize}

I tre bit possono essere memorizzati nel campo \verb+mchunk_size+ perchè le dimensioni dei chunk sono sempe allineate ad 8 byte (o 16 in sistemi a 64 bit), per cui i tre bit meno significativi sono sempre a zero.