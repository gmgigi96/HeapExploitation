\section{Heap\todo{Cambiare titolo}}
Il funzionamento dell'heap dipende sia dalla piattaforma che dalla specifica implementazione. Ad esempio, in sistemi embedded le implementazioni normalmente utilizzati usano una lista concatenata con politica LIFO di blocchi di memoria di dimensione prefissata. Anche l'implementazione nella \emph{glibc}, la libreria standard del linguaggio C, di Linux è completamente differente da quella di Windows. In particolare, nella nostra trattazione, si vedrà l'implementazione dell'allocatore in heap nella glibc di un sistema Linux, \emph{ptmalloc2}, che deriva dalla \emph{ptmalloc}, che a sua volta deriva da una vecchia implementazione, \emph{dlmalloc}.

Uno dei problemi principali di cui soffre l'heap per sua natura è la \emph{frammentazione}: ci saranno quindi sezioni inutilizzate di memoria interposte tra sezioni in uso. Un buon allocatore dovrà limitare questo fenomeno, cercando di unire spazi contigui non utilizzati per soddisfare una richiesta.

\verb+malloc+ e \verb+free+, non sono gli unici modi con cui un programmatore C/C++ può interagire con l'heap: si possono infatti utilizzare funzioni come \verb+calloc+, \verb+realloc+, \verb+memalign+, che come \+malloc+, possono essere rilasciate con \verb+free+. I programmatori C++, invece, possono allocare memoria in heap con gli operatori \verb+new+ e \verb+new[]+, e deallocarla con \verb+delete+ e \verb+delete[]+.

L'allocatore della glibc di Linux, divide l'heap in chunk, ovvero porzioni di memoria più grandi rispetto a quelli richiesti da un programmatore. Questo per contenere metadati utili alla gestione dei chunk nell'heap.
Inoltre, poichè l'allocatore non conosce come un programmatore utilizza i dati allocati in memoria, esso deve garantire che i dati siano allineati. Questo ha impatto sulle performace di un software. La glibc allinea i chunk a 8 byte in sistemi a 32 bit ed a 16 byte in sistemi a 64 bit.

\subsection{Strategia di base}
Vediamo come vengono allocati i chunk, in un allocatore il cui funzionamento è molto semplificato:
\begin{enumerate}
	\item se un precedente chunk liberato con \verb+free+ è sufficientemente grande da contenere l'attuale, si usa questo chunk;\label{base:free}
	\item altrimenti, se c'è abbastanza spazio nel \emph{top chunk}, lo spazio più in alto nell'heap, si crea un nuovo chunk, riducendo il top chunk, e si restituisce questo;
	\item altrimenti, l'allocatore chiederà al kernel più spazio per l'heap, e se questo verrà aumentato sufficientemente da contenere il nuovo chunk viene creato dal nuovo spazio;\label{base:syscall}
	\item altrimenti, la richiesta non può essere soddisfatta e la \verb+malloc+ restituisce \verb+NULL+.
\end{enumerate}

Per il punto~\ref{base:free}, l'heap mantiene una o più liste di chunk, denominati \emph{bin}, gestite alcune con poliche LIFO, altre FIFO, altre ancora ordinate per chunk. Queste liste possono essere semplicemente o doppiamente concatenate, circolari, con nodi \emph{dummy}. Se è presente un chunck con una dimensione sufficientemente grande da soddisfare una richiesta, questo chunk viene estratto da uno dei bin.\todo{Inserire figura bin}

Nel punto~\ref{base:syscall}, le system call che l'allocatore può utilizzare per richiedere più spazio in heap sono \verb+brk+\cite{brk_syscall} e \verb+mmap+\cite{mmap_syscall}.
\verb+brk+ ottiene memoria, non inizializzata a zero, dal kernel incrementanfo il \emph{program break location}, o \emph{brk}. L'inizio dell'heap si trova invece in \emph{start\_brk}. Quando ASLR è disattivato, \emph{start\_brk} punta alla fine del BSS segment, altrimenti, se attivo, viene aggiunto un offset random (vedi Figura~\ref{fig:proc}). Ora, poichè il loader inserisce l'heap subito dopo BSS, l'effetto della syscall \verb+brk+ è quello di aumentare/diminuire la dimensione dell'heap.
\verb+mmap+ è utilizzato da \verb+malloc+ per chiedere al kernel zone mappate in memoria anonime, inizializzate a zero, usabili esclusivamente dal processo richiedente. Quest'ultima system call è usata quando \verb+sbrk+ fallisce, ad esempio perchè l'heap è cresciuto troppo da poter collidere con altre zone del processo, come shared libraries.

Le richieste per regioni di memoria molto ampie sono servite dall'allocatore direttamente da \verb+mmap+. Il comportamento è gestito dalla variabile \verb+M_MMAP_THRESHOLD+, che in sistemi a 32 bit è normalmente 128k e in sistemi a 64 bit è 32M. \'E possibile comunque cambiare la questa variabile con la funzione \verb+mallopt+. Le regioni \emph{mmappate} vengono marcate da una flag che indica che sono state ottenute da una chiamata ad \verb+mmap+, in modo tale che ad una richiesta a \verb+free+, la regione viene deallocata con la syscall \verb+munmap+.

\subsection{Chunk metadata}
Un chunk, come detto in precedenza, contiene dei metadati per la gestione degli stessi nell'heap. Nella glibc la struttura di un chunk è denominata \verb+malloc_chunk+, ed è così definita:

\begin{lstlisting}[style=CStyle]
struct malloc_chunk {
	INTERNAL_SIZE_T mchunk_prev_size;  /* Size of previous chunk (if free). */
	INTERNAL_SIZE_T mchunk_size;       /* Size in bytes, including overhead */
	struct malloc_chunk* fd;           /* double links -- used only if free */
	struct malloc_chunk* bk;
}
\end{lstlisting}

Alcuni di questi campi sono usati o meno in base al fatto che il chunk è in uso o libero.
Un chunk in uso ha questo aspetto:

\begin{verbatim}
    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|M|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             User data starts here...                          .
            .                                                               .
            .             (malloc_usable_size() bytes)                      .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             (size of chunk, but used for application data)    |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|1|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}

Da notare che in questo caso \verb+fd+ e \verb+bk+ non sono utilizzati, ma coincidono con la parte del chunk utilizzabile dall'applicazione, lo \emph{user data}. \verb+mem+ è infatti il puntatore ritornato dalla \verb+malloc+.

Un chunk libero, quindi al'interno di un bin, avrà questo aspetto:

\begin{verbatim}
    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of previous chunk, if unallocated (P clear)  |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of chunk, in bytes                     |A|0|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Forward pointer to next chunk in list             |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Back pointer to previous chunk in list            |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Unused space (may be 0 bytes long)                .
            .                                                               .
            .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
            |             Size of next chunk, in bytes                |A|0|0|
            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
\end{verbatim}
Qui lo user data è occupato dai puntatori \verb+fd+ e \verb+bk+\footnote{in base al bin in cui andrà a finire il chunk possono essere usati o entrambi o solo uno dei due.}.

In entrambi i casi il campo \verb+mchunk_prev_size+ è utilizzato solo se il chunk precedente\footnote{in questo caso il chunk precedente è quello che lo precede fisicamente in memoria} è libero e se è in uso può contenere gli user data del chunk precedente.

Il lettore avrà anche notato la presenza di 3 lettere nel campo \verb+mchunk_size+, che corrispondono ai 3 bit meno significativi di questo campo:
\begin{itemize}
	\item \textbf{P (PREV\_INUSE)}: 0 quando il chunk precedente in memoria è libero e la dimensione di quest'ultimo è memorizzata nel primo campo. Se il bit è 1, il chunk precedente è utilizzato e non si può conoscere la sua dimensione.
	\item \textbf{M (IS\_MMAPPED)}: se 1 il chunk è ottenuto mediante la syscall \verb+mmap+. Gli altri due bit sono ignorati.
	\item \textbf{A (NON\_MAIN\_ARENA)}: se 0 il chunk è nel main arena. Ogni thread del processo riceve la sua arena e per questi chunk il bit è settato ad 1.
\end{itemize}

I tre bit possono essere memorizzati nel campo \verb+mchunk_size+ perchè le dimensioni dei chunk sono sempe allineate ad 8 byte (o 16 in sistemi a 64 bit), per cui i tre bit meno significativi sono sempre a zero.

\subsection{Arena\todo{Scrivere arena}}
\lipsum[1]

\subsection{Free bins}
I chunk liberati vanno a finire nei corrispondenti \emph{free bin}, che non sono altro che liste di chunk. Per questo lo user data, che nei chunk liberi è per definizione libero, contiene i puntatori ai chunk precedenti e successivi.
Inoltre i chunk liberi memorizzano il \verb+chunk_size+, i bit \verb+A+ e \verb+P+, ma non usano il bit \verb+M+, poichè i chunk mmappati vengono liberati direttamente con \verb+munmap+ e non vengono riutilizzati.

Poichè la \verb+malloc+ è una componente fondamentale in qualsiasi programma, deve utilizzare alcuni stratagemmi per non impattare troppo sulle performance.
Per migliorare le performance, invece che contenere i chunk in un'unica lista, esistono una serie di liste di chunk, denominati \emph{bin}, progettati per massimizzare l'allocazione e la deallocazione.

Ci sono 5 tipi di bin: 62 \emph{small bin}, 63 \emph{large bin}, 1 \emph{unsorted bin}, 10 \emph{fast bin} e 64 \emph{tcache bin} per thread.
Small, large ed unsorted bin si trovano nello stesso array, in cui l'indice 0 non è usato, 1 è l'unsorted bin, 2-64 sono small bin e 65-127 sono large bin.
I fast bin e le tcache rappresentano una cache per velocizzare la ricerca di chunk liberi.\todo{inserire immagine array dei bin}

\paragraph{Small bin}
Esistono 62 small bin, gestiti come liste doppiamente concatenate, ciascuno contenente chunk della stessa dimensione. In sistemi a 32 bit gli small bin contengono chunk con dimensione minore di 512 byte, in sistemi a 64 byte chunk con dimensione minore di 1024 byte. Gli small bin, contenendo chunk della stessa dimensione, sono già ordinati per cui l'inserimento e la rimozione sono molto veloci.

\paragraph{Large bin}
Non essendo possibile mantenere bin contenenti chunk di qualsiasi dimensione possibile, per chunk maggiori di 512 byte, l'allocatore utilizza i large bin. Esistono 63 large bin, che mantengono chunk di dimensione in un determinato range, progettato in modo tale che non ci sia sovrapposizione con gli small bin e i large bin. In altre parole, dato un chunk, esiste solo uno small bin o large bin in cui può essere inserito.
I large bin, non contenendo chunk di dimensioni prefissati come gli small bin, sono mantenuti ordinati ad ogni allocazione. Questo li rende molto più lenti rispetto gli small bin.

I primi 32 bin contengono chunk spaziati di 64 byte, i successivi 16 bin chunk spaziati di 512 byte, e così via fino a raggiungere l'ultimo bin che contiene tutto il resto (vedi Tabella~\ref{tab:bin}.

\begin{table}
	\centering
	\begin{tabular}{lll}
		\# bin & Spaziamento & Tipo \\
		\midrule
		64 & 8 & Small bin     \\
		32 & 64 & Large bin      \\
		16 & 512 & Large bin  \\
		8 & 4096 & Large bin  \\
		4 & 32768 & Large bin  \\
		2 & 262144 & Large bin \\
		1 & rimanente & Large bin \\
		\bottomrule
	\end{tabular}
	\vspace{0.15in}
	\caption{Divisione dei bin}
	\label{tab:bin}
\end{table}

\paragraph{Unsorted bin}
C'è un solo unsorted bin. Sia small chunk che large chunk, quando sono liberati, finiscono in questo bin. Questo perchè la maggior parte dei programmi effettua una \verb+free+ su un insieme di chunk per poi allocare un certo numero di chunk di dimensione simile. In questi casi non conviene unire chunk vicini per formare chunk più grandi per poi inserirli nei bin appositi, ma è utile aver pronti subito questi chunk. L'unsorted bin si comporta come un layer di cache.
Durante una \verb+malloc+, si verifica se esiste almeno un elemento in questo bin che può soddisfare la richiesta. Se esiste, \verb+malloc+ lo restituisce, altrimenti inserisce i chunk nei rispettivi small e large bin.

\paragraph{Fast bin}
I fast bin contengono chunk che non vengono uniti ai chunk liberi vicini, in modo tale che se una richiesta arriva in un tempo relativamente breve rispetto a quando il chunk viene liberato, questa può essere servita immediatamente. Come gli small bin, i fast bin contengono chunk di dimensioni prefissate. In particolare esistono 10 fast bin, di dimensioni 16, 24, 32, 40, 48, 56, 64, 72, 80, 88.
Non essendo uniti ad altri chunk, il bit \verb+P+ del chunk successivo non è settato, quindi è come se l'allocatore non liberi effettivamente questi chunk.

Come gli small bin, i chunk in un fast bin sono per loro natura già ordinati, per cui l'inserimento e la rimozione è molto veloce. Visto che i chunk non vengono uniti ai chunk liberi vicini, un fast bin è gestito come una lista singolarmente concatenata.

Il lato negativo dei fast bin è che, non liberando effettivamente i chunk, la memoria con il tempo può frammentarsi. Per questo, periodicamente i chunk nei fast bin vengono \emph{consolidati}, ovvero vengono uniti i chunk liberi vicini e messi i chunk risultanti nell'unsorted bin.

Il consolidamento avviene quando una richiesta a \verb+malloc+ non può essere soddisfatta da un fast bin, quando si libera un chunk più grande di 64KB, oppure quando viene richiamata la funzione \verb+mallopt+ o \verb+malloc_trim+.

\paragraph{Tcache}
L'ultimo livello di ottimizzazione al di sopra di tutti i bin, introdotto dalla versione 2.26 della glibc, è la tcache. Le tcache, \emph{per-thread cache}, sono dei bin posseduti esclusivamente dai singoli thread. In un'applicazione multithread, quando un thread richiede spazio all'heap, essendo questo comune a tutti i thread di un processo, deve aspettare un lock su una variabile mutex per poter ottenere un chunk libero. Essendo l'allocazione e la deallocazione in memoria operazioni eseguite frequentemente, questo può portare ad un degrado delle prestazioni.
Quindi ogni thread mantiene 64 tcache, organizzate secondo liste singolarmente concatenate. Ogni bin contiene al massimo 7 chunk di dimensioni comprese tra 24 e 1032 byte in sistemi a 64 bit e tra 12 e 516 byte in sistemi a 32 bit.

Il funzionamento è il seguente: quando un chunk viene liberato, l'allocatore controlla se questo puù entrare in un tcache bin relativo alla sua dimensione. Come i fast bin, i chunk nel tcache sono considerati in uso e quindi non sono uniti con i vicini.

Se la tcache per quel chunk è pieno, il thread chiede un lock all'heap e gestisce il chunk secondo il vecchio approccio.

Quando, invece, viene richiesto spazio all'heap, se esiste un chunk nel tcache che può soddisfare la richiesta questo viene immediatamente restituito, senza che venga chiesto alcun lock, altrimenti si richiede il lock all'heap e si continua come prima, con la differenza che si cerca di riempire con più chunk possibili le tcache mentre si mantiene il lock sull'heap.

\subsection{Algoritmo della \texttt{malloc}}
I passi eseguiti dalla \verb+malloc+ sono:
\begin{enumerate}
	\item se la dimensione corrisponde ad un tcache bin e c'è un tcache chunk disponibile, restituiscilo.
	\item se la richiesta è superiore a \verb+M_MMAP_THRESHOLD+, il chunk viene allocato tramite \verb+mmap+.
	\item altrimenti si richiede il lock all'arena, svolgendo successivamente i seguenti passi:
	\begin{enumerate}
		\item \textbf{Strategia fastbin/smallbin}
		\begin{itemize}
			\item se il chunk può essere contenuto in un fastbin, cerca un chunk in quel fastbin (cercando di riempire la tcache con gli elementi del fastbin).
			\item altrimenti, se il chunk può essere contenuto in uno smallbin, cerca un chunk in quel smallbin (cercando di riempiera la tcache con gli elementi dello smallbin).
		\end{itemize}
		\item \textbf{Libera i chunk in attesa}
		\begin{itemize}
			\item libera \emph{effettivamente} ogni elemento nei fastbin, consolidali con i vicini e spostali nell'unsorted bin.
			\item per ogni elemento dell'unsorted bin, cerca il chunk in grado di soddisfare la richiesta. Se esiste restituiscilo, altrimenti inserisci ogni elemento nel corrispondente small/large bin (cercando di riempire la tcache con gli elementi che andrebbero nello smallbin).
		\end{itemize}
		\item \textbf{Strategia base di riutilizzo dei chunk}
		\begin{itemize}
			\item cerca il chunk nel corrispondente largebin, se la dimensione corrisponde ad uno dei largebin
		\end{itemize}
		\item \textbf{Crea un nuovo chunk}
		\begin{itemize}
			\item altrimenti, se non ci sono chunk disponibili, vedi se c'è spazio nel top chunk.
			\item se il top chunk non è abbastanza grande, chiedi spazio al kernel con \verb+brk+.
			\item se l'heap non può essere esteso, richiedi uno spazio in memoria tramite \verb+mmap+ e alloca il chunk da lì.
		\end{itemize}
		\item \textbf{Fallisci, restituendo \texttt{NULL}}
	\end{enumerate}

\end{enumerate}

\subsection{Algoritmo della \texttt{free}}
L'algoritmo eseguito dalla \verb+free+ è il seguente:
\begin{enumerate}
	\item se il puntatore è \verb+NULL+, non fare niente
	\item altrimenti, calcola il puntatore al chunk ottenuto sottraendo al puntatore ricevuto la dimensione dei metadata di un chunk
	\item se il chunk può entrare in un tcache bin, inseriscilo lì dentro.
	\item se il chunk ha il bit \verb+M+ ad 1, liberalo con \verb+munmap+.
	\item altrimenti si chiede il lock sull'arena, svolgendo successivamente i seguenti passi:
	\begin{enumerate}
		\item se un chunk può andare in un fastbin, inseriscilo nel corrispondente fastbin.
		\item altrimenti, se la dimensione del chunk è maggiore di 64KB, consolida i chunk contenuti nei fastbin e inserisci li nell'unsorted bin (sarà compito della \verb+malloc+ di inserirli eventualmente nei corrispondenti small/large bin)
		\item fondi il chunk con i precedenti ed i successivi
		\item se il chunk ottenuto si trova nel top heap, il chunk diventa il nuovo top chunk
		\item altrimenti inseriscilo nell'unsorted bin.
	\end{enumerate}
\end{enumerate}
